10 marts:
Vi skal finde ud af om Rust threads er anderledes håndteret end POSIX threads?
Spawner POSIX threads en ny proces? Vi kan jo nok kalde Andersens bibliotek 
igennem Rust med det der foreign library interface, og få den samme slags
threading og dermed de samme resultater. Men vi skal bare være forsigtig med 
hvordan vi formulerer os om dens multi thread egenskaber.

Vi kunne også overveje at have en branch uden locks, og på den måde teste lock
overhead af Rust locks.

Vi må også udnytte synchronization featuren til at starte alle test threads 
samtidigt.

I dag har vi undrsøgt hvordan man skal arbejde med shared mutable state i 
Rust. Rusts type system beskytter dig imod dette normalt, ved ikke at tillade
funktioner at returnere andet end en ejet pointer. Hvis en lånt pointer 
returneres er det fordi den peger ind i en datastruktur som du har givet 
funktionen som argument. Hvorfor er dette sikkert? 
- Hvis man returnerer en owned
pointer så har vi kun en reference til det sted i hukommelsen, hvilket er 
sikkert. Grunden til at vi kan returnere en pointer og at den pointer ikke
er "out of scope" når funktionen afslutter er fordi Rust er smart og kan 
"infere" at det vi allokerer noget som returneres, og derfor gør den det så det
ikke bliver frigjort. 
- Det er også sikkert at returnere en reference men kun hvis den referer
til noget i en datastruktur vi har modtaget som argument. det er fordi at vi 
ved at når funktionen bliver kaldt så har vi lånt objektet vi kalder med, og 
derfor er dens scope størrere end funktionen. Vi kan derfor returnere det 
lånte objekt eller en del af det, uden at forbryde os mod memory safety. 
Hvorfor kan man ikke returnere en lånt pointer ellers? Fordi hvis den er lånt 
tilskriver man sig ikke ejerskab, og når selve den lånte pointer går "out of 
scope" så bliver det den pejer på ikke frigjort. At returnere en lånt pointer 
til noget allokeret inde i funktionen giver ikke mening, fordi den lånte 
pointer vil pege på noget som er frigjort efter funktionen.

Hvordan beskytter det dig mod race conditions? Fordi man ikke kan have 
adskillige referencer til det samme hukommelse, uden at bruge sikre biblioteks
metoder. To processer kan altså ikke referere til det samme hukommelse uden et 
bibliotek. Hvordan er biblioteket sikkert? Fordi den er "atomically reference 
counted", dvs. holder styr på hvor mange referencer der er til den del af 
hukommelsen. Således kan hukommelse ikke frigøres hvis pointere til den eksister. 
Biblioteket bruger i virkeligheden "unsafe" kode, i det de 
returnerer en pointer til dataen som hverken er owned eller borrowed, og 
derfor ingen beskyttelse har. Man kan derfor kalde dens funktioner, som vha. 
locks er thread safe. I tilfælde af ARC returneres kun "immutable" references 
som er thread safe i det du så kun kan aflæse, eller kalde metoder som ikke 
kræver at man har mutable rettigheder på objektet. Ved kald af Drop på en 
pointer returneret fra ARC (når pointer løber ud af scope) så decrementerer
ARC antallet af pointere som referer til den, og når tallet når 0 kan den selv 
droppes.

Nogle metoder kræver omvendt mutate rettigheder hvis de ændrer objektet, 
hvilket igen er umuligt at undgå med Rusts type system, da hver metode som 
argument modtager self. Hvis metoden skal læse/skrive sig selv, SKAL den kalde 
self, og da self ikke kan skrives uden mutable rettigheder kan vi ikke 
skrive/ændre objektet uden mutable rettigheder.

Så for at opsummere: Man kan ikke med Rusts typesystem ikke have mere end en
reference til et objekt, og med den reference vil man aldrig kunne skrive/ændre
i uden mutable rettigheder. Så ARC behøves blot at sørge for at objektet den 
wrapper ikke frigøres så længe nogle peger på den. Dette gør den blot med en 
simpel counter. I det den returnerer en pointer til et immutable objekt, vil 
typesystemet sørge for at intet i objektet kan skrives/ændres.

Rust tvinger dig altså til virkelig at overveje hvilke resourcer tilhører hvem,
og hvorvidt du har brug for at læse/ændre dem. Disse tvugne overvejelser 
passer godt ind i concurrency modellen, hvor man igen må gøre sig nøje 
overvejelser om hvilke resourcer tilhører hvem.
Ender man med at køre "unsafe" kode og bryde reglerne, er det forhåbenligt et 
meget begrænset mængde kode der kan forvolde problemer, og som man nemmere kan 
fikse.

For at vores HashMap er thread safe skal det have en metode som returnerer en
pointer som er hverken er owned eller borrowed så folk kan kalde metoderne
concurrently.

10 april:
Antal af cache lines der hives ind for et lookup som der skal alle elementer 
i en virtuel bucket igennem:
______________________________
| Antal buckets | cache lines |
|      16       |     4       |
|      32       |     8       |
|      64       |    16       |
______________________________

13 april:
Raw table begyndt, vi kan snart have et eksperimentielt hash table klar.
